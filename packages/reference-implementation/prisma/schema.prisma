generator client {
  provider      = "prisma-client-js"
  output        = "../src/lib/prisma/generated"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("RI_DATABASE_URL")
}

enum DidType {
  DEFAULT
  MANAGED
  SELF_MANAGED
}

enum DidMethod {
  DID_WEB
  DID_WEB_VH
}

enum DidStatus {
  ACTIVE
  INACTIVE
  VERIFIED
  UNVERIFIED
}

enum ServiceType {
  DID
  IDR
}

enum AdapterType {
  VCKIT
  PYX_IDR
}

/**
 * Auth.js + Prisma adapter tables for OAuth + JWT sessions
 */
model User {
  id              String    @id @default(cuid())
  authProviderId  String?   @unique
  name            String?
  email           String?   @unique
  emailVerified   DateTime?
  image           String?
  tenantId        String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  accounts     Account[]
  tenant       Tenant? @relation(fields: [tenantId], references: [id], onDelete: SetNull)
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  access_token      String?
  refresh_token     String?
  expires_at        Int?
  id_token          String?
  token_type        String?
  scope             String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Tenant {
  id             String   @id @default(cuid())
  name           String
  primaryColor   String?
  secondaryColor String?
  logo           String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  users              User[]
  dids               Did[]
  serviceInstances   ServiceInstance[]
  registrars         Registrar[]
  schemes            IdentifierScheme[]
  identifiers        Identifier[]
  linkRegistrations  LinkRegistration[]

  @@map("Tenant")
}

/**
 * Stores issued verifiable credentials metadata
 */
model Credential {
  id             String   @id @default(cuid())
  storageUri     String
  hash           String
  decryptionKey  String?
  credentialType String
  isPublished    Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

/**
 * DID records scoped to organisations (tenants).
 * Supports three tiers: DEFAULT (system-wide), MANAGED, and SELF_MANAGED.
 */
model Did {
  id             String    @id @default(cuid())
  tenantId       String
  did            String    @unique
  type           DidType
  method         DidMethod @default(DID_WEB)
  name           String
  description    String?
  keyId          String
  status         DidStatus @default(UNVERIFIED)
  isDefault      Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  serviceInstanceId String?
  serviceInstance   ServiceInstance? @relation(fields: [serviceInstanceId], references: [id], onDelete: SetNull)

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

/**
 * Registered service instances scoped to organisations (tenants).
 * Each instance stores AES-256-GCM encrypted configuration for its adapter.
 */
model ServiceInstance {
  id             String       @id @default(cuid())
  tenantId       String
  serviceType    ServiceType
  adapterType    AdapterType
  name           String
  description    String?
  config         String       // AES-256-GCM encrypted JSON blob
  apiVersion     String       // Semver without v prefix, e.g. "1.1.0"
  isPrimary      Boolean      @default(false)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  tenant         Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  dids           Did[]
  registrars     Registrar[]        @relation("RegistrarIdr")
  schemes        IdentifierScheme[] @relation("SchemeIdr")

  @@index([tenantId, serviceType])
}

/**
 * Registrars are organisations that operate identifier schemes.
 * Scoped to tenants, with system defaults available to all.
 */
model Registrar {
  id                   String   @id @default(cuid())
  tenantId             String
  name                 String
  namespace            String
  url                  String?
  idrServiceInstanceId String?
  isDefault            Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  tenant             Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  idrServiceInstance ServiceInstance? @relation("RegistrarIdr", fields: [idrServiceInstanceId], references: [id], onDelete: SetNull)
  schemes            IdentifierScheme[]

  @@index([tenantId])
}

/**
 * Identifier schemes define a type of identifier with validation rules.
 * Each scheme belongs to a registrar and may have qualifier definitions.
 */
model IdentifierScheme {
  id                   String   @id @default(cuid())
  tenantId             String
  registrarId          String
  name                 String
  primaryKey           String
  validationPattern    String
  namespace            String?
  idrServiceInstanceId String?
  isDefault            Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  tenant             Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  registrar          Registrar        @relation(fields: [registrarId], references: [id], onDelete: Cascade)
  idrServiceInstance ServiceInstance? @relation("SchemeIdr", fields: [idrServiceInstanceId], references: [id], onDelete: SetNull)
  qualifiers         SchemeQualifier[]
  identifiers        Identifier[]

  @@unique([registrarId, primaryKey, tenantId])
  @@index([tenantId])
}

/**
 * Qualifier definitions for identifier schemes (e.g. batch number, serial number).
 * Each qualifier belongs to exactly one scheme.
 */
model SchemeQualifier {
  id                String   @id @default(cuid())
  schemeId          String
  key               String
  description       String
  validationPattern String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  scheme IdentifierScheme @relation(fields: [schemeId], references: [id], onDelete: Cascade)

  @@unique([schemeId, key])
}

/**
 * Actual identifier values validated against their scheme's pattern.
 * Scoped to a single tenant (not shared with system defaults).
 */
model Identifier {
  id        String   @id @default(cuid())
  tenantId  String
  schemeId  String
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant            Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  scheme            IdentifierScheme   @relation(fields: [schemeId], references: [id], onDelete: Restrict)
  linkRegistrations LinkRegistration[]

  @@unique([schemeId, value])
  @@index([tenantId])
}

/**
 * Audit trail for links published to IDR services.
 * Each record maps a local identifier to an IDR-assigned link.
 */
model LinkRegistration {
  id            String   @id @default(cuid())
  tenantId      String
  identifierId  String
  idrLinkId     String
  linkType      String
  targetUrl     String
  mimeType      String
  resolverUri   String
  qualifierPath String?
  publishedAt   DateTime @default(now())

  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  identifier Identifier @relation(fields: [identifierId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([identifierId])
}
